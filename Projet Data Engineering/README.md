---
# Food Buy API

## Ressources

* Project objectives : 

## Dependencies

* Anaconda or Miniconda: https://docs.conda.io/projects/conda/en/latest/user-guide/install/index.html

## Setup

1. Create a new conda env named md4-api (if you haven't already) for the project in the Conda application or in the terminal:
```
conda create --name md4-api python=3.7 
```

2. Activate the conda env (you can check your availables env with: conda env list):
```
conda activate md4-api
```

3. Install the project python dependencies :
```
pip install -r requirements.txt
```

4. Install flask in your terminal to be able to launch it:
```
conda install -c conda-forge flask
```

5. Launch the API :
```
flask run --port=3000
```

## Development

To enable automatic re-launch of the API (hot reload) when there is a code update, launch flask like this:
```
FLASK_DEBUG=1 flask run --port=3000
```

## Database

To connect to a database, you must set the environment variable `DATABASE_URL` in the .env file with a valid connection URI.

Example of PostgreSQL uri:
```
DATABASE_URL=postgresql://user:password@database_host:database_port/database_name
```

To apply the database migrations (located in migrations/versions), you can use this command:
```
flask db upgrade
```

To create a new migration, you can use this command and then apply the previous command:
```
flask db migrate -m "Migration message"
```

If your database is empty and you want some random data to start working with your API, you can use this command:
```
flask seed
```
It will fill your database with a test user.

## OpenFoodFacts API


### Création de la route: GET /products/:bar_code

format des informations à récupérer depuis le json: 

**Nutriscore**: ```"nutriscore_grade": "X",```  

**marque**: ```"brands": "XXX",```  

**produit**: ```"product_name_fr": "XXX"```

---
récupération grâce à la fonction: ```get_product_by_code(self, bar_code)```
si le produit se situe dans la BDD: affichage
sinon: recupération via l'API, enregistrement des 3 nouveaux champs + ```bar_code``` dans la BDD et affichage. 

## WIP:

* routes purchase, problème avec la longueur du code bar, pas de problème sur les autres routes, modèle similaire. 

* routes ranking pas terminées, finir purchase obligatoirement.

* Docker pas entièrement fonctionnel, lien vers la BDD KO. BDD fonctionne correctement en local.

* AWS terminé, fonction lambda pour la récupération automatique des transactions presque terminée. plus qu'a plugger. 

## Docker Setup

## docker build
```docker build -t foodbuy-api .```
## Docker run commands
```shell
docker run --name postgres-db -p 3000:3000 -v /Users/anis/Documents/Code/HETIC/MD4/Python/foodbuy-md4-api-2022/data:/db  -e POSTGRES_PASSWORD=password -e POSTGRES_USER=postgres -e POSTGRES_DB=postgres_db -d postgres
```

## docker-compose

```docker
services:
  api:
    depends_on:
      - database
    build: .
    ports:
      - "3000:3000"
    environment:
      DATABASE_URL: "postgresql://postgres:password@database:3000/postgres_db"

  database:
    container_name: postgres_db
    image: postgres
    ports:
      - "3300:3000"
    environment:
      POSTGRES_PASSWORD: "password"
      POSTGRES_DB: "postgres_db"
      PG_DATA: "/data/db"
    volumes:
       - ./data:/data/db

  pgadmin:
    container_name: pgadmin4_container
    image: dpage/pgadmin4
    restart: always
    environment:
      PGADMIN_DEFAULT_EMAIL: openfoodfact@project.com
      PGADMIN_DEFAULT_PASSWORD: password
    ports:
      - "5050:80"
```

## PgAdmin:

```http://localhost:5050/```
```
email: openfoodfact@project.com
password: password
(à définir dans le docker-compose)
```
 
 
```
Name: postgres_db (pas obligatoire)
host name: postgres_db (nom du container postres)
port: 5432 (valeur par defautl pour les connexions à postgres)
maintenance database: postgres_db (nom de la BDD)
username: postgres (celui de la BDD)
password: password (celui de la BDD)
```

## Project structure


-- cli : this folder will code to define custom flask commands
    
-- database : this folder will contains all database models
    
----- models.py : contains class definitions for each database model

-- migrations : generated by the Flask CLI (flask db init)
    
----- versions : will contains the list of database migrations

------- xxx.py : "xxx" will be replaced by a migration ID and commit message

-- resources : this folder will contains all the resources of the API
    
----- xxx.py : "xxx" will be replaced by the resource name

-- app.py : the main API file that will list all the available endpoints

-- config.py : this file will contain the configuration of the api

-- requirements.txt : this files will list the dependencies of the project

